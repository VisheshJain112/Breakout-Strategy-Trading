# -*- coding: utf-8 -*-
"""Ate breakout strategy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B1Yb-RzP83CRxOGU3TlTKHgaUu6d2yWo
"""

from google.colab import files
uploaded = files.upload()

import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

print("Loading...")

plt.rcParams['figure.figsize'] = (5,5)
data = pd.read_csv(io.BytesIO(uploaded['eod-quotemedia.csv']),parse_dates=['date'],index_col=False)
close=data.reset_index().pivot(index='date', columns='ticker', values='adj_close')
high=data.reset_index().pivot(index='date', columns='ticker', values='adj_high')
low=data.reset_index().pivot(index='date', columns='ticker', values='adj_low')
def get_lookback(close,high,low,lookbackdays):
  lookback_high=high.rolling(lookbackdays).max().shift(1)
  lookback_low=low.rolling(lookbackdays).min().shift(1)
  return lookback_high,lookback_low
lookback_high,lookback_low=get_lookback(close,high,low,50)
def get_signal(close,lookback_high,lookback_low):
  signal=close.copy()
  signal[:]=0
  signal[close>lookback_high]=1
  signal[close<lookback_low]=-1
  return signal
def clear_signal(signal,window):
  cleared_signal=[0]*window
  for signal_i,signal in enumerate(signal):
    past_signal=bool(sum(cleared_signal[signal_i:signal_i+window]))
    current_signal= not past_signal and signal
    cleared_signal.append(current_signal)
  cleared_signal=cleared_signal[window:]
  cleared_signal=np.array(cleared_signal)
  cleared_signal=cleared_signal.astype(int)
  return cleared_signal


def filter_signal(signal,lookahead_days):
  filtered_signal=signal.copy()
  pos=signal.copy()
  neg=signal.copy()
  pos[pos<1]=0
  neg[neg>1]=0
  for col in signal.columns:
    pos[col]=clear_signal(pos[col],lookahead_days)
    neg[col]=clear_signal(-1*neg[col],lookahead_days)
    filtered_signal[col]=pos[col]-neg[col]
  return filtered_signal

signal_5=filter_signal(get_signal(close,lookback_high,lookback_low),5)
signal_10=filter_signal(get_signal(close,lookback_high,lookback_low),10)
signal_20=filter_signal(get_signal(close,lookback_high,lookback_low),20)

def signal_return(signal,close,lookahead_days):
  lookahead_return=close.shift(-lookahead_days)
  lookahead_returns=signal.copy()
  lookahead_returns=np.log(lookahead_return)-np.log(close)
  signal_return=signal * lookahead_returns
  return signal_return

signal_return_5=signal_return(signal_5,close,5)

signal_return_10=signal_return(signal_10,close,10)
signal_return_20=signal_return(signal_20,close,20)

long_short_signal_return_5=signal_return_5[signal_5!=0].stack()
long_short_signal_return_10=signal_return_10[signal_10!=0].stack()
long_short_signal_return_20=signal_return_20[signal_20!=0].stack()
long_short_signal_return_5=long_short_signal_return_5.reset_index()

long_short_signal_return_5=long_short_signal_return_5.set_index(long_short_signal_return_5['ticker'])
long_short_signal_return_5=long_short_signal_return_5.drop(columns=['date','ticker'])

  
long_short_signal_return_5=long_short_signal_return_5.rename({0:'signal_returns'},axis=1)
long_short_signal_return_10=long_short_signal_return_10.reset_index()

long_short_signal_return_10=long_short_signal_return_10.set_index(long_short_signal_return_10['ticker'])
long_short_signal_return_10=long_short_signal_return_10.drop(columns=['date','ticker'])

  
long_short_signal_return_10=long_short_signal_return_10.rename({0:'signal_returns'},axis=1)
long_short_signal_return_20=long_short_signal_return_20.reset_index()

long_short_signal_return_20=long_short_signal_return_20.set_index(long_short_signal_return_20['ticker'])
long_short_signal_return_20=long_short_signal_return_20.drop(columns=['date','ticker'])

  
long_short_signal_return_20=long_short_signal_return_20.rename({0:'signal_returns'},axis=1)

from scipy.stats import kstest
def calculate_kstest(signal):
  ticker_list=[]
  ks_value=[]
  p_value=[]
  mean_args=np.mean(signal['signal_returns'])
  std_args=np.std(signal['signal_returns'])
  normal_args=(mean_args,std_args)
  for ticker_name,group in signal.groupby(['ticker']):
    kv,pv=kstest(group['signal_returns'],'norm',normal_args)
    ticker_list.append(ticker_name)
    ks_value.append(kv)
    p_value.append(pv)
  ksvalue=pd.Series(data=ks_value,index=ticker_list)
  pvalue=pd.Series(data=p_value,index=ticker_list)
  return ksvalue,pvalue
ks_val_5,p_val_5=calculate_kstest(long_short_signal_return_5)
ks_val_10,p_val_10=calculate_kstest(long_short_signal_return_10)
ks_val_20,p_val_20=calculate_kstest(long_short_signal_return_20)
def find_outliers(ks_val,p_val,k_thre):
  outliers=[]
  p_thre=0.05
  for ticker,ks_value in ks_val.iteritems():
    if (p_val[ticker]<p_thre and ks_val[ticker]>k_thre):
      outliers.append(ticker)
  set(outliers)
  return outliers
ks_threshold = 0.25

outliers_5 = find_outliers(ks_val_5, p_val_5, ks_threshold)
outliers_10 = find_outliers(ks_val_10, p_val_10, ks_threshold)
outliers_20 = find_outliers(ks_val_20, p_val_20, ks_threshold)
outlier_tickers = set(outliers_5).union(set(outliers_10)).union(set(outliers_20))
good_tickers=list(set(close.columns)-outlier_tickers)
signal_return_5[good_tickers].hist()
plt.show()

import pandas as pd
import numpy as np
data = pd.read_csv(io.BytesIO(uploaded['eod-quotemedia.csv']),parse_dates=['date'],index_col=False)
close=data.reset_index().pivot(index='date', columns='ticker', values='adj_close')
high=data.reset_index().pivot(index='date', columns='ticker', values='adj_high')
low=data.reset_index().pivot(index='date', columns='ticker', values='adj_low')
def get_high_lows_lookback(high, low, lookback_days):
    #TODO: Implement function
    # obtain the rolling max over the high datafame in a lookback_days window
    # and shift 1 day to not to include the current day
    lookback_high = high.rolling(lookback_days).max().shift(1)
    # obtain the rolling min over the low datafame in a lookback_days window
    # and shift 1 day to not to include the current day
    lookback_low = low.rolling(lookback_days).min().shift(1)
    # return highs_in_low and lows_in_window
    return lookback_high, lookback_low
lookback_days = 50
lookback_high, lookback_low = get_high_lows_lookback(high, low, lookback_days)
def get_long_short(close, lookback_high, lookback_low):
    """
    Generate the signals long, short, and do nothing.
    
    Parameters
    ----------
    close : DataFrame
        Close price for each ticker and date
    lookback_high : DataFrame
        Lookback high price for each ticker and date
    lookback_low : DataFrame
        Lookback low price for each ticker and date
    
    Returns
    -------
    long_short : DataFrame
        The long, short, and do nothing signals for each ticker and date
    """
    #TODO: Implement function
    # copy close DataFrame as long_short DataFrame
    long_short = close.copy()
    # set all values in long_short DataFrame to 0
    long_short[:] = 0
    # convert values in long_short to integer
    long_short = long_short.astype(np.int)
    # set long_short signal to -1 if lookback_high > close
    long_short[lookback_low > close] = -1
    # set long_short signal to +1 if lookback_high < close
    long_short[lookback_high < close] = 1
    # return long_short DataFrame
    return long_short
signal = get_long_short(close, lookback_high, lookback_low)
def clear_signals(signals, window_size):
    """
    Clear out signals in a Series of just long or short signals.
    
    Remove the number of signals down to 1 within the window size time period.
    
    Parameters
    ----------
    signals : Pandas Series
        The long, short, or do nothing signals
    window_size : int
        The number of days to have a single signal       
    
    Returns
    -------
    signals : Pandas Series
        Signals with the signals removed from the window size
    """
    # Start with buffer of window size
    # This handles the edge case of calculating past_signal in the beginning
    clean_signals = [0]*window_size
    
    for signal_i, current_signal in enumerate(signals):
        # Check if there was a signal in the past window_size of days
        has_past_signal = bool(sum(clean_signals[signal_i:signal_i+window_size]))
        # Use the current signal if there's no past signal, else 0/False
        clean_signals.append(not has_past_signal and current_signal)
        
    # Remove buffer
    clean_signals = clean_signals[window_size:]

    # Return the signals as a Series of Ints
    return pd.Series(np.array(clean_signals).astype(np.int), signals.index)


def filter_signals(signal, lookahead_days):
    """
    Filter out signals in a DataFrame.
    
    Parameters
    ----------
    signal : DataFrame
        The long, short, and do nothing signals for each ticker and date
    lookahead_days : int
        The number of days to look ahead
    
    Returns
    -------
    filtered_signal : DataFrame
        The filtered long, short, and do nothing signals for each ticker and date
    """
    #TODO: Implement function
    # copy signal DataFrame as filtered_signal DataFrame
    filtered_signal = signal.copy()
    # loop over all the columns in signal DataFramme using DataFrame.iteritems() function
    # index is the ticker and column is a Pandas Series
    for index, column in signal.iteritems():
        # TREAT THE POSITIVE SIGNALS IN THE TICKER SERIES
        # copy the column as positive_signal Series
        positive_signal = column.copy()
        # assign as 0 value the -1 values in positive_signal
        positive_signal[positive_signal < 0] = 0
        # clear the signal over the positive_signal Series with clear_signals() function
        cleaned_signal_pos = clear_signals(positive_signal, lookahead_days)
        # TREAT THE NEGATIVE SIGNALS IN THE TICKER SERIES
        # copy the column as negative_signal Series
        negative_signal = column.copy()
        # assign as 0 value the +1 values in negative_signal
        negative_signal[negative_signal > 0] = 0
        # clear the signal over the negative_signal Series with clear_signals() function
        cleaned_signal_neg = clear_signals(-1*negative_signal, lookahead_days)
        # JOINT THE POSITIVE AND NEGATIVE SIGNALS IN THE TICKER SERIES
        # obtain cleaned_signal Series as a sum of cleaned_signal_pos and (-1)*cleaned_signal_neg
        cleaned_signal = cleaned_signal_pos - cleaned_signal_neg
        # OBTAIN THE filtered_signal DATAFRAME
        # assign the cleaned signal Series to the filtered_signal DataFrame
        # for each of the indexes (tickers)
        filtered_signal[index] = cleaned_signal
    # return filtered_signal DataFrame
    return filtered_signal
signal_5 = filter_signals(signal, 5)
signal_10 = filter_signals(signal, 10)
signal_20 = filter_signals(signal, 20)
def get_lookahead_prices(close, lookahead_days):
    """
    Get the lookahead prices for `lookahead_days` number of days.
    
    Parameters
    ----------
    close : DataFrame
        Close price for each ticker and date
    lookahead_days : int
        The number of days to look ahead
    
    Returns
    -------
    lookahead_prices : DataFrame
        The lookahead prices for each ticker and date
    """
   
    # shift the prices a -lookahead_days value to 
    # bring the future value to the present date
    lookahead_prices = close.shift(-lookahead_days)
    #return lookahead_prices
    return lookahead_prices


lookahead_5 = get_lookahead_prices(close, 5)
lookahead_10 = get_lookahead_prices(close, 10)
lookahead_20 = get_lookahead_prices(close, 20)

def get_return_lookahead(close, lookahead_prices):
    """
    Calculate the log returns from the lookahead days to the signal day.
    
    Parameters
    ----------
    close : DataFrame
        Close price for each ticker and date
    lookahead_prices : DataFrame
        The lookahead prices for each ticker and date
    
    Returns
    -------
    lookahead_returns : DataFrame
        The lookahead log returns for each ticker and date
    """
    # copy close DataFrame as long_short DataFrame
    lookahead_returns = close.copy()
    # compute the log returns as:
    # ln(lookahead_prices) - ln(close)
    lookahead_returns = np.log(lookahead_prices) - np.log(close)
    # return the lookahead_returns DataFrame
    return lookahead_returns

price_return_5 = get_return_lookahead(close, lookahead_5)
price_return_10 = get_return_lookahead(close, lookahead_10)
price_return_20 = get_return_lookahead(close, lookahead_20)
def get_signal_return(signal, lookahead_returns):
    """
    Compute the signal returns.
    
    Parameters
    ----------
    signal : DataFrame
        The long, short, and do nothing signals for each ticker and date
    lookahead_returns : DataFrame
        The lookahead log returns for each ticker and date
    
    Returns
    -------
    signal_return : DataFrame
        Signal returns for each ticker and date
    """

    # to obtain the returs associate to each signal, we multiply 
    # the signal DataFrame for the lookahead_returns DataFrame
    signal_return = signal * lookahead_returns
    # return signal_return
    return signal_return
signal_return_5 = get_signal_return(signal_5, price_return_5)
signal_return_10 = get_signal_return(signal_10, price_return_10)
signal_return_20 = get_signal_return(signal_20, price_return_20)
# Filter out returns that don't have a long or short signal.
long_short_signal_returns_5 = signal_return_5[signal_5 != 0].stack()
long_short_signal_returns_10 = signal_return_10[signal_10 != 0].stack()
long_short_signal_returns_20 = signal_return_20[signal_20 != 0].stack()

# Get just ticker and signal return
long_short_signal_returns_5 = long_short_signal_returns_5.reset_index().iloc[:, [1,2]]
long_short_signal_returns_5.columns = ['ticker', 'signal_return']
long_short_signal_returns_10 = long_short_signal_returns_10.reset_index().iloc[:, [1,2]]
long_short_signal_returns_10.columns = ['ticker', 'signal_return']
long_short_signal_returns_20 = long_short_signal_returns_20.reset_index().iloc[:, [1,2]]
long_short_signal_returns_20.columns = ['ticker', 'signal_return']
from scipy.stats import kstest


def calculate_kstest(long_short_signal_returns):
    """
    Calculate the KS-Test against the signal returns with a long or short signal.
    
    Parameters
    ----------
    long_short_signal_returns : DataFrame
        The signal returns which have a signal.
        This DataFrame contains two columns, "ticker" and "signal_return"
    
    Returns
    -------
    ks_values : Pandas Series
        KS static for all the tickers
    p_values : Pandas Series
        P value for all the tickers
    """
  
    # initialize tickers list
    tickers_list = []
    # initialize ks values list
    ks_list = []
    # initialize p values list
    p_list = []
    # compute the normal_args (mean, std) for the normal
    # distribution of long_short_signal_returns
    # compute the mean argument
    mean_arg = np.mean(long_short_signal_returns['signal_return'])
    # compute the std argument with ddof=0 (degrees of freedom)
    std_arg = np.std(long_short_signal_returns['signal_return'], ddof=0)
    # obtain the normal arguments tuple
    normal_args = (mean_arg, std_arg)
    # loop over the long_short_signal_returns DataFrame using groupby() function
    for ticker_name, group in long_short_signal_returns.groupby(['ticker']):
        # obtain the ks statistic and the p_value
        ks_v, p_v = kstest(group['signal_return'], 'norm', normal_args)
        # append the ticker_name to the tickers_list
        tickers_list.append(ticker_name)
        # append the ks_v to the ks_list
        ks_list.append(ks_v)
        # append the p_v to the p_list
        p_list.append(p_v)
    # build the ks_values Series
    ks_values = pd.Series(data=ks_list, index=tickers_list)
    # build the p_values Series
    p_values = pd.Series(data=p_list, index=tickers_list)
    # return the ks_values Series and the p_values Series
    return ks_values, p_values

ks_values_5, p_values_5 = calculate_kstest(long_short_signal_returns_5)
ks_values_10, p_values_10 = calculate_kstest(long_short_signal_returns_10)
ks_values_20, p_values_20 = calculate_kstest(long_short_signal_returns_20)
def find_outliers(ks_values, p_values, ks_threshold, pvalue_threshold=0.05):
    """
    Find outlying symbols using KS values and P-values
    
    Parameters
    ----------
    ks_values : Pandas Series
        KS static for all the tickers
    p_values : Pandas Series
        P value for all the tickers
    ks_threshold : float
        The threshold for the KS statistic
    pvalue_threshold : float
        The threshold for the p-value
    
    Returns
    -------
    outliers : set of str
        Symbols that are outliers
    """
    
    outliers = []
    # loop over tickers and values in ks_values Series
    for ticker,value in ks_values.iteritems():
        # if p_value for the ticker is less than pvalue_threshold
        # or ks_value for the ticker is greater than ks_threshold
        if (p_values[ticker]<pvalue_threshold) and (ks_values[ticker]>ks_threshold):
            # append ticker to the list of outliers
            outliers.append(ticker)
    # transform the outliers list in a set
    outliers = set(outliers)
    # return outliers set
    return outliers
ks_threshold = 0.8
outliers_5 = find_outliers(ks_values_5, p_values_5, ks_threshold)
outliers_10 = find_outliers(ks_values_10, p_values_10, ks_threshold)
outliers_20 = find_outliers(ks_values_20, p_values_20, ks_threshold)

outlier_tickers = outliers_5.union(outliers_10).union(outliers_20)
print('{} Outliers Found:\n{}'.format(len(outlier_tickers), ', '.join(list(outlier_tickers))))

def clear_signal(signal,window):
  cleared_signal=[0]*window
  for signal_i,signal in enumerate(signal):
    past_signal=bool(sum(cleared_signal[signal_i:signal_i+window]))
    current_signal= not past_signal and signal
    cleared_signal.append(current_signal)
  cleared_signal=cleared_signal[window:]
  cleared_signal=np.array(cleared_signal)
  cleared_signal.astype(int)
  return cleared_signal


def filter_signal(signal,lookahead_days):
  
  pos=signal.copy()
  neg=signal.copy()
  pos=np.array(pos)
  neg=np.array(neg)
  pos=np.where(pos<1,0,1)
  neg=np.where(neg>1,0,-1)

  pos=clear_signal(pos,lookahead_days)
  neg=clear_signal(neg,lookahead_days)

  print(pos)
  print(neg)
signal=[-1,0,0,1,0,1,0,-1,-1]
print(filter_signal(signal,3))